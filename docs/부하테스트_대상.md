# 부하 테스트 계획서

**작성자**: 홍석호  
**작성일**: 2025-04-04  
**버전**: 1.0

## 개요

핵심 기능 3개(선착순 쿠폰 발급, 상위 상품 조회, 주문 요청)의 부하 테스트 계획을 제시합니다. **단일 서버(t2.micro)의 최대 처리 능력**을 측정하여 분산 환경에서 필요한 서버 대수를 산정합니다.

**서비스 규모 가정**:
- DAU: 100,000명
- 평균 동시 접속자: 2,500-3,000명 (DAU 2.5~3% 가정)
- 이벤트 시 최대 동시 접속: 8,000-10,000명(DAU 8-10% 가정)
- 일일 주문: 1,500-2,000건(DAU 1.5-2% 가정)

**테스트 목적**: 
서버 한 대가 처리할 수 있는 최대 부하 측정 → 전체 트래픽 분산 설계에 활용

**이 문서의 결과물:**
- 부하 테스트 대상 기능과 선정 기준
- 기능별 상세 테스트 시나리오
- 테스트 환경 구성 방법
- k6 스크립트 구현 가이드
- 부하 테스트 결과

---

## 부하 테스트 대상 기능

### 1. 선착순 쿠폰 발급

**기능**: 제한된 수량의 쿠폰을 선착순으로 발급

**선정 이유**: 이벤트 시작 시점에 동시 요청이 집중되어 시스템에 최대 부하를 발생시키는 기능

**아키텍처**:
![kafka_coupon_issue.png](image/kafka_coupon_issue.png)

**측정 목표**:
- **단일 서버 최대 TPS 측정**
- 쿠폰 발급 성공률과 중복 발급률
- 성능 한계점에서의 응답 시간 분포

### 2. 상위 상품 조회

**기능**: 판매량 기준 상위 상품 목록 조회

**선정 이유**: 메인 페이지 노출로 높은 조회 빈도와 지속적인 트래픽 발생

**아키텍처**:
![캐시전략_스케줄러.png](image/캐시전략_스케줄러.png)
![캐시전략_조회.png](image/캐시전략_조회.png)

**측정 목표**:
- **단일 서버 최대 조회 TPS 측정**
- Redis 캐시 히트율 (목표: 90% 이상)
- 성능 한계점에서의 응답 시간 분포

### 3. 주문 요청

**기능**: 상품 주문 처리

**선정 이유**: 비즈니스 핵심 기능으로 모든 상황에서 안정적 처리 필요

**아키텍처**:
![order_scenario.png](image/order_scenario.png)

**측정 목표**:
- **단일 서버 최대 주문 처리 TPS 측정**
- 주문 성공률 (목표: 98% 이상)
- 성능 한계점에서의 응답 시간 분포

---

## 테스트 시나리오

![load_test_scenario.png](image/load_test_scenario.png)

### 1. 선착순 쿠폰 발급 시나리오

**테스트 데이터**:
- 쿠폰 1,000개 발급
- 쿠폰 데이터 Redis에 캐싱
- MySQL에 쿠폰과 사용자 정보 저장

**트래픽 패턴**: 점진적 스파이크 (단일 서버 한계 측정)
- 100명 → 200명 → 500명 → 1,000명 → 1,500명 단계적 증가
- 각 단계마다 성능 지표 측정
- 에러율 5% 초과 시점을 서버 한계로 판단

**측정 지표**:
- 쿠폰 발급 요청 성공률
- 중복 발급률
- 초당 트랜잭션 처리 수(TPS)
- p99.9, p99, p95, p80, p50, avg 응답 시간

### 2. 상위 상품 조회 시나리오

**테스트 데이터**:
- Redis에 상위 상품 데이터 캐싱
- MySQL에 10000개의 상품 데이터에 대해서 상품별 재고 정보 저장

**트래픽 패턴**: 점진적 부하 증가 (단일 서버 한계 측정)
- 평상시: 100명 → 300명 → 500명 → 800명 단계적 증가
- 각 단계에서 5분간 유지하며 성능 측정
- 응답 시간 1초 초과 또는 에러율 1% 초과 시 한계 판단

**측정 지표**:
- 캐시 히트율
- 초당 트랜잭션 처리 수(TPS)
- p99.9, p99, p95, p80, p50, avg 응답 시간

### 3. 주문 요청 시나리오

**테스트 데이터**:
- MySQL에 10000개의 상품 데이터 저장
- 상품별 최소 100개의 재고 설정

**트래픽 패턴**: 점진적 부하 증가 (단일 서버 한계 측정)
- 초당 1건 → 3건 → 5건 → 10건 → 15건 단계적 증가
- 각 단계에서 10분간 유지하며 안정성 확인
- 주문 실패율 2% 초과 시 한계 판단

**측정 지표**:
- 주문 성공률
- 초당 트랜잭션 처리 수(TPS)
- p99.9, p99, p95, p80, p50, avg 응답 시간

---

## 테스트 환경

**클라우드 환경 (AWS 기준)**:
- EC2 t2.micro: 1 vCPU, 1GB RAM (최소 스펙 유지)
- RDS MySQL t4g.micro: 2 vCPU, 1GB RAM
- ElastiCache Redis t4g.micro: 2 vCPU, 1GB RAM
- MSK Kafka m7g.large: 2 vCPU, 8GB RAM

**로컬 환경**: Docker Compose로 동일 스펙 구성

**목적**: 최소 스펙 서버 한 대의 처리 한계 측정 → DAU 10만명 대응 시 필요 서버 대수 산정

---

## 테스트 도구 및 스크립트

**사용 도구**: k6 (오픈소스 부하 테스트 도구)

### 선착순 쿠폰 발급 스크립트
```javascript
import http from 'k6/http';
import { check, sleep } from 'k6';

// 테스트 설정
export const options = {
  stages: [
    // 점진적 스파이크 패턴
    { duration: '1m', target: 100 },  // 100명까지 증가
    { duration: '2m', target: 100 },  // 100명 유지
    { duration: '1m', target: 200 },  // 200명까지 증가
    { duration: '2m', target: 200 },  // 200명 유지
    { duration: '1m', target: 500 },  // 500명까지 증가
    { duration: '2m', target: 500 },  // 500명 유지
    { duration: '1m', target: 1000 }, // 1000명까지 증가
    { duration: '2m', target: 1000 }, // 1000명 유지
    { duration: '1m', target: 1500 }, // 1500명까지 증가
    { duration: '2m', target: 1500 }, // 1500명 유지
    { duration: '2m', target: 0 },    // 종료
  ],
  thresholds: {
    http_req_failed: ['rate<0.05'], // 에러율 5% 미만
    http_req_duration: ['p(95)<2000'], // 95%ile 응답시간 2초 미만
    coupon_issue_success_rate: ['rate>0.95'], // 쿠폰 발급 성공률 95% 이상
  },
};

// 테스트 데이터 설정
const BASE_URL = __ENV.BASE_URL || 'http://localhost:8080';
const COUPON_ID = 1; // 테스트용 쿠폰 ID
const MAX_USER_ID = 10000; // 최대 사용자 ID

export default function () {
  // 랜덤 사용자 ID 생성 (1~10000)
  const userId = Math.floor(Math.random() * MAX_USER_ID) + 1;
  
  const payload = JSON.stringify({
    userId: userId,
    couponId: COUPON_ID
  });

  const params = {
    headers: {
      'Content-Type': 'application/json',
    },
  };

  // 쿠폰 발급 요청
  const response = http.post(`${BASE_URL}/api/v1/coupons/issue`, payload, params);
  
  // 응답 검증
  const isSuccess = check(response, {
    'status is 200': (r) => r.status === 200,
  });

  // 실제 사용자 행동 시뮬레이션을 위한 대기
  sleep(Math.random() * 2 + 1); // 1-3초 랜덤 대기
}
```

### 상위 상품 조회 스크립트  
```javascript
import http from 'k6/http';
import { check, sleep } from 'k6';

// 테스트 설정
export const options = {
  stages: [
    // 점진적 부하 증가 패턴
    { duration: '2m', target: 100 },  // 100명까지 증가
    { duration: '5m', target: 100 },  // 100명 유지
    { duration: '2m', target: 300 },  // 300명까지 증가
    { duration: '5m', target: 300 },  // 300명 유지
    { duration: '2m', target: 500 },  // 500명까지 증가
    { duration: '5m', target: 500 },  // 500명 유지
    { duration: '2m', target: 800 },  // 800명까지 증가
    { duration: '5m', target: 800 },  // 800명 유지
    { duration: '3m', target: 0 },    // 종료
  ],
  thresholds: {
    http_req_failed: ['rate<0.01'], // 에러율 1% 미만
    http_req_duration: ['p(95)<1000'], // 95%ile 응답시간 1초 미만
    product_query_success_rate: ['rate>0.99'], // 조회 성공률 99% 이상
  },
};

// 테스트 데이터 설정
const BASE_URL = __ENV.BASE_URL || 'http://localhost:8080';

export default function () {
  const params = {
    headers: {
      'Content-Type': 'application/json',
    },
  };

  // 상위 상품 조회 요청
  const response = http.get(`${BASE_URL}/api/v1/products/top-selling`, params);
  
  // 응답 검증
  const isSuccess = check(response, {
    'status is 200': (r) => r.status === 200,
  });

  // 실제 사용자 행동 시뮬레이션
  sleep(Math.random() * 3 + 2); // 2-5초 랜덤 대기 (상품 목록 확인 시간)
}
```

### 주문 요청 스크립트
```javascript
import http from 'k6/http';
import { check, sleep } from 'k6';

// 테스트 설정
export const options = {
  stages: [
    // 점진적 부하 증가 패턴 (낮은 TPS로 시작)
    { duration: '5m', target: 5 },   // 초당 약 1건
    { duration: '10m', target: 5 },  // 초당 약 1건 유지
    { duration: '5m', target: 15 },  // 초당 약 3건
    { duration: '10m', target: 15 }, // 초당 약 3건 유지
    { duration: '5m', target: 25 },  // 초당 약 5건
    { duration: '10m', target: 25 }, // 초당 약 5건 유지
    { duration: '5m', target: 50 },  // 초당 약 10건
    { duration: '10m', target: 50 }, // 초당 약 10건 유지
    { duration: '5m', target: 75 },  // 초당 약 15건
    { duration: '10m', target: 75 }, // 초당 약 15건 유지
    { duration: '5m', target: 0 },   // 종료
  ],
  thresholds: {
    http_req_failed: ['rate<0.02'], // 에러율 2% 미만
    http_req_duration: ['p(95)<5000'], // 95%ile 응답시간 5초 미만
    order_success_rate: ['rate>0.98'], // 주문 성공률 98% 이상
  },
};

// 테스트 데이터 설정
const BASE_URL = __ENV.BASE_URL || 'http://localhost:8080';
const MAX_USER_ID = 10000;
const MAX_PRODUCT_ID = 10000;
const MAX_PRODUCT_OPTION_ID = 50000;

// 테스트용 주문 데이터 생성 함수
function generateOrderData() {
  const userId = Math.floor(Math.random() * MAX_USER_ID) + 1;
  const productId = Math.floor(Math.random() * MAX_PRODUCT_ID) + 1;
  const productOptionId = Math.floor(Math.random() * MAX_PRODUCT_OPTION_ID) + 1;
  const amount = Math.floor(Math.random() * 3) + 1; // 1-3개 주문
  
  // 30% 확률로 쿠폰 사용
  const userCouponId = Math.random() < 0.3 ? Math.floor(Math.random() * 1000) + 1 : null;

  return {
    userId: userId,
    userCouponId: userCouponId,
    amountProductOptions: [
      {
        productId: productId,
        productOptionId: productOptionId,
        amount: amount
      }
    ]
  };
}

export default function () {
  const orderData = generateOrderData();
  
  const payload = JSON.stringify(orderData);

  const params = {
    headers: {
      'Content-Type': 'application/json',
    },
  };

  // 주문 생성 요청
  const response = http.post(`${BASE_URL}/api/v1/orders`, payload, params);
  
  // 응답 검증
  const isSuccess = check(response, {
    'status is 200 or 201': (r) => r.status === 200,
  });

  // 주문 성공 시 결제 요청 (50% 확률)
  if (isSuccess && Math.random() < 0.5) {
    sleep(1); // 주문 후 결제까지 잠시 대기
    
    const paymentPayload = JSON.stringify({
      userId: orderData.userId
    });

    // 실제로는 주문 ID가 필요하지만, 여기서는 단순화
    const paymentResponse = http.post(
      `${BASE_URL}/api/v1/orders/1/payment`, 
      paymentPayload,
      params
    );

    check(paymentResponse, {
      'payment status is 200': (r) => r.status === 200,
    });
  }

  // 실제 사용자 행동 시뮬레이션
  sleep(Math.random() * 5 + 3); // 3-8초 대기 (주문 고민 시간)
}
```

## 부하 테스트 결과